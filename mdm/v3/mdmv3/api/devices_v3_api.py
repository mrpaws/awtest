# coding: utf-8

"""
    MDM API V3

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 3
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from mdmv3.api_client import ApiClient


class DevicesV3Api(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def devices_v3_get_by_uuid_async(self, uuid, **kwargs):  # noqa: E501
        """New - Get basic details about the device.  # noqa: E501

        Get basic information about the device based on the unique identifier passed in the path. The response contains hypermedia links, which can be followed to get more information about the device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_v3_get_by_uuid_async(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: Device unique identifier.(Required). (required)
        :return: DeviceResponseV3Model
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_v3_get_by_uuid_async_with_http_info(uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_v3_get_by_uuid_async_with_http_info(uuid, **kwargs)  # noqa: E501
            return data

    def devices_v3_get_by_uuid_async_with_http_info(self, uuid, **kwargs):  # noqa: E501
        """New - Get basic details about the device.  # noqa: E501

        Get basic information about the device based on the unique identifier passed in the path. The response contains hypermedia links, which can be followed to get more information about the device.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_v3_get_by_uuid_async_with_http_info(uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uuid: Device unique identifier.(Required). (required)
        :return: DeviceResponseV3Model
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_v3_get_by_uuid_async" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uuid' is set
        if self.api_client.client_side_validation and ('uuid' not in params or
                                                       params['uuid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `uuid` when calling `devices_v3_get_by_uuid_async`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=3'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/{uuid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceResponseV3Model',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_v3_search_async(self, **kwargs):  # noqa: E501
        """New - Searches the device using the query information provided.  # noqa: E501

        Get basic information about the device with maximum pagesize limit of 500. If page size is greater than the maximum limit, it will return the first 500 records.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_v3_search_async(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Username the device enrolled under.
        :param str model_identifier: Partial search by device model. Search by MD20 would return device with model MD200LL.
        :param str device_type: Device platform type, i.e. Apple, Android, WindowsPC, etc.
        :param datetime last_seen: Last seen date string.
        :param str ownership: Device ownership.
        :param str organization_group_uuid: Organization Group to be searched. User's OG is considered if not specified.
        :param str compliance_status: Compliance status.
        :param datetime seen_since: Specifies the date filter for device search, which retrieves the devices that are seen after this date.
        :param int page: Specific page number to get. 0 based index.
        :param int page_size: Maximum records per page. Default 500.
        :param str order_by: Order by column name.
        :param str sort_order: Sorting order. Values ASC or DESC. Defaults to ASC.
        :return: DeviceSearchResultExtendedV2
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_v3_search_async_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.devices_v3_search_async_with_http_info(**kwargs)  # noqa: E501
            return data

    def devices_v3_search_async_with_http_info(self, **kwargs):  # noqa: E501
        """New - Searches the device using the query information provided.  # noqa: E501

        Get basic information about the device with maximum pagesize limit of 500. If page size is greater than the maximum limit, it will return the first 500 records.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_v3_search_async_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str user: Username the device enrolled under.
        :param str model_identifier: Partial search by device model. Search by MD20 would return device with model MD200LL.
        :param str device_type: Device platform type, i.e. Apple, Android, WindowsPC, etc.
        :param datetime last_seen: Last seen date string.
        :param str ownership: Device ownership.
        :param str organization_group_uuid: Organization Group to be searched. User's OG is considered if not specified.
        :param str compliance_status: Compliance status.
        :param datetime seen_since: Specifies the date filter for device search, which retrieves the devices that are seen after this date.
        :param int page: Specific page number to get. 0 based index.
        :param int page_size: Maximum records per page. Default 500.
        :param str order_by: Order by column name.
        :param str sort_order: Sorting order. Values ASC or DESC. Defaults to ASC.
        :return: DeviceSearchResultExtendedV2
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user', 'model_identifier', 'device_type', 'last_seen', 'ownership', 'organization_group_uuid', 'compliance_status', 'seen_since', 'page', 'page_size', 'order_by', 'sort_order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_v3_search_async" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'user' in params:
            query_params.append(('user', params['user']))  # noqa: E501
        if 'model_identifier' in params:
            query_params.append(('model_identifier', params['model_identifier']))  # noqa: E501
        if 'device_type' in params:
            query_params.append(('device_type', params['device_type']))  # noqa: E501
        if 'last_seen' in params:
            query_params.append(('last_seen', params['last_seen']))  # noqa: E501
        if 'ownership' in params:
            query_params.append(('ownership', params['ownership']))  # noqa: E501
        if 'organization_group_uuid' in params:
            query_params.append(('organization_group_uuid', params['organization_group_uuid']))  # noqa: E501
        if 'compliance_status' in params:
            query_params.append(('compliance_status', params['compliance_status']))  # noqa: E501
        if 'seen_since' in params:
            query_params.append(('seen_since', params['seen_since']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501
        if 'order_by' in params:
            query_params.append(('order_by', params['order_by']))  # noqa: E501
        if 'sort_order' in params:
            query_params.append(('sort_order', params['sort_order']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=3'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/devices/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceSearchResultExtendedV2',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
