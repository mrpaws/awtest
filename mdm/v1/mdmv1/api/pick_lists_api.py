# coding: utf-8

"""
    MDM API V1

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from mdmv1.api_client import ApiClient


class PickListsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def pick_lists_get_allowed_geo_fencing_area_ids_by_lg(self, ogid, **kwargs):  # noqa: E501
        """Gets Geo Fencing Areas by Og Id.  # noqa: E501

        Method to load area entities for a given location group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_allowed_geo_fencing_area_ids_by_lg(ogid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ogid: Og Id (Required). (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_allowed_geo_fencing_area_ids_by_lg_with_http_info(ogid, **kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_allowed_geo_fencing_area_ids_by_lg_with_http_info(ogid, **kwargs)  # noqa: E501
            return data

    def pick_lists_get_allowed_geo_fencing_area_ids_by_lg_with_http_info(self, ogid, **kwargs):  # noqa: E501
        """Gets Geo Fencing Areas by Og Id.  # noqa: E501

        Method to load area entities for a given location group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_allowed_geo_fencing_area_ids_by_lg_with_http_info(ogid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ogid: Og Id (Required). (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ogid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_allowed_geo_fencing_area_ids_by_lg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ogid' is set
        if self.api_client.client_side_validation and ('ogid' not in params or
                                                       params['ogid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ogid` when calling `pick_lists_get_allowed_geo_fencing_area_ids_by_lg`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ogid' in params:
            path_params['ogid'] = params['ogid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/organizationgroups/{ogid}/geofencingareas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_allowed_time_fencing_schedule_ids_by_lg(self, ogid, **kwargs):  # noqa: E501
        """Gets Allowed Time Fencing Schedules by Og Id.  # noqa: E501

        Method to load Schedule entities for a given location group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_allowed_time_fencing_schedule_ids_by_lg(ogid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ogid: Og Id (Required). (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_allowed_time_fencing_schedule_ids_by_lg_with_http_info(ogid, **kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_allowed_time_fencing_schedule_ids_by_lg_with_http_info(ogid, **kwargs)  # noqa: E501
            return data

    def pick_lists_get_allowed_time_fencing_schedule_ids_by_lg_with_http_info(self, ogid, **kwargs):  # noqa: E501
        """Gets Allowed Time Fencing Schedules by Og Id.  # noqa: E501

        Method to load Schedule entities for a given location group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_allowed_time_fencing_schedule_ids_by_lg_with_http_info(ogid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ogid: Og Id (Required). (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ogid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_allowed_time_fencing_schedule_ids_by_lg" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ogid' is set
        if self.api_client.client_side_validation and ('ogid' not in params or
                                                       params['ogid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ogid` when calling `pick_lists_get_allowed_time_fencing_schedule_ids_by_lg`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ogid' in params:
            path_params['ogid'] = params['ogid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/organizationgroups/{ogid}/timefencingschedules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_certificate_authority_list(self, ogid, **kwargs):  # noqa: E501
        """Gets the list of Certificate Authorities (CA) for an organization group.  # noqa: E501

        Retrieves the list of Certificate Authority (CA) for an organization group.  In cryptography, a certificate authority is an entity that issues digital certificates. A digital certificate certifies the ownership of a public key by the named subject of the certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_certificate_authority_list(ogid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ogid: Organization Group Id. (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_certificate_authority_list_with_http_info(ogid, **kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_certificate_authority_list_with_http_info(ogid, **kwargs)  # noqa: E501
            return data

    def pick_lists_get_certificate_authority_list_with_http_info(self, ogid, **kwargs):  # noqa: E501
        """Gets the list of Certificate Authorities (CA) for an organization group.  # noqa: E501

        Retrieves the list of Certificate Authority (CA) for an organization group.  In cryptography, a certificate authority is an entity that issues digital certificates. A digital certificate certifies the ownership of a public key by the named subject of the certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_certificate_authority_list_with_http_info(ogid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ogid: Organization Group Id. (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ogid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_certificate_authority_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ogid' is set
        if self.api_client.client_side_validation and ('ogid' not in params or
                                                       params['ogid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ogid` when calling `pick_lists_get_certificate_authority_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ogid' in params:
            path_params['ogid'] = params['ogid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/organizationgroups/{ogid}/certificateauthorities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_certificate_store_for_windows_mobile(self, **kwargs):  # noqa: E501
        """Gets Certificate Store for WindowsMobile.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_certificate_store_for_windows_mobile(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_certificate_store_for_windows_mobile_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_certificate_store_for_windows_mobile_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_certificate_store_for_windows_mobile_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Certificate Store for WindowsMobile.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_certificate_store_for_windows_mobile_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_certificate_store_for_windows_mobile" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowsmobilecertificatestore', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_certificate_templates_for_certificate_authority(self, og_id, certificate_authority_id, **kwargs):  # noqa: E501
        """Gets Certificate Templates List for Certificate Authority.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_certificate_templates_for_certificate_authority(og_id, certificate_authority_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int og_id: Og Id. (required)
        :param int certificate_authority_id: Certificate Authority Id. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_certificate_templates_for_certificate_authority_with_http_info(og_id, certificate_authority_id, **kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_certificate_templates_for_certificate_authority_with_http_info(og_id, certificate_authority_id, **kwargs)  # noqa: E501
            return data

    def pick_lists_get_certificate_templates_for_certificate_authority_with_http_info(self, og_id, certificate_authority_id, **kwargs):  # noqa: E501
        """Gets Certificate Templates List for Certificate Authority.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_certificate_templates_for_certificate_authority_with_http_info(og_id, certificate_authority_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int og_id: Og Id. (required)
        :param int certificate_authority_id: Certificate Authority Id. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['og_id', 'certificate_authority_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_certificate_templates_for_certificate_authority" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'og_id' is set
        if self.api_client.client_side_validation and ('og_id' not in params or
                                                       params['og_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `og_id` when calling `pick_lists_get_certificate_templates_for_certificate_authority`")  # noqa: E501
        # verify the required parameter 'certificate_authority_id' is set
        if self.api_client.client_side_validation and ('certificate_authority_id' not in params or
                                                       params['certificate_authority_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `certificate_authority_id` when calling `pick_lists_get_certificate_templates_for_certificate_authority`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'og_id' in params:
            path_params['ogId'] = params['og_id']  # noqa: E501
        if 'certificate_authority_id' in params:
            path_params['certificateAuthorityId'] = params['certificate_authority_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/organizationgroups/{ogId}/certificateauthorities/{certificateAuthorityId}/getcertificatetemplates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_certificate_templates_list_for_certificate_authority(self, ogid, certificate_authority_id, **kwargs):  # noqa: E501
        """Gets the list of Certificate Templates for a Certificate Authority (CA).  # noqa: E501

        Retrieves the list of Certificate templates for an organization group.  A Certificate template is a preconfigured list of certificate settings that allows users and computers to enroll for certificates without having to create complex certificate requests.  Enterprise certification authorities (CAs) use certificate templates to define the format and content of certificates, to specify which users and computers can enroll for which types of certificates,  and to define the enrollment process, such as autoenrollment, enrollment only with authorized signatures, and manual enrollment.  Associated with each certificate template is a discretionary access control list (DACL) that defines which security principals have permissions to read and configure the template,  as well as to enroll or autoenroll for certificates based on the template. The certificate templates and their permissions are defined in Active Directory® Domain Services (AD DS) and are valid within the forest.  If more than one enterprise CA is running in the Active Directory forest, permission changes will affect all enterprise CAs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_certificate_templates_list_for_certificate_authority(ogid, certificate_authority_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ogid: Organization Group Id. (required)
        :param int certificate_authority_id: Certificate Authority Id. (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_certificate_templates_list_for_certificate_authority_with_http_info(ogid, certificate_authority_id, **kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_certificate_templates_list_for_certificate_authority_with_http_info(ogid, certificate_authority_id, **kwargs)  # noqa: E501
            return data

    def pick_lists_get_certificate_templates_list_for_certificate_authority_with_http_info(self, ogid, certificate_authority_id, **kwargs):  # noqa: E501
        """Gets the list of Certificate Templates for a Certificate Authority (CA).  # noqa: E501

        Retrieves the list of Certificate templates for an organization group.  A Certificate template is a preconfigured list of certificate settings that allows users and computers to enroll for certificates without having to create complex certificate requests.  Enterprise certification authorities (CAs) use certificate templates to define the format and content of certificates, to specify which users and computers can enroll for which types of certificates,  and to define the enrollment process, such as autoenrollment, enrollment only with authorized signatures, and manual enrollment.  Associated with each certificate template is a discretionary access control list (DACL) that defines which security principals have permissions to read and configure the template,  as well as to enroll or autoenroll for certificates based on the template. The certificate templates and their permissions are defined in Active Directory® Domain Services (AD DS) and are valid within the forest.  If more than one enterprise CA is running in the Active Directory forest, permission changes will affect all enterprise CAs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_certificate_templates_list_for_certificate_authority_with_http_info(ogid, certificate_authority_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int ogid: Organization Group Id. (required)
        :param int certificate_authority_id: Certificate Authority Id. (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ogid', 'certificate_authority_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_certificate_templates_list_for_certificate_authority" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ogid' is set
        if self.api_client.client_side_validation and ('ogid' not in params or
                                                       params['ogid'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `ogid` when calling `pick_lists_get_certificate_templates_list_for_certificate_authority`")  # noqa: E501
        # verify the required parameter 'certificate_authority_id' is set
        if self.api_client.client_side_validation and ('certificate_authority_id' not in params or
                                                       params['certificate_authority_id'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `certificate_authority_id` when calling `pick_lists_get_certificate_templates_list_for_certificate_authority`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ogid' in params:
            path_params['ogid'] = params['ogid']  # noqa: E501
        if 'certificate_authority_id' in params:
            path_params['certificateAuthorityId'] = params['certificate_authority_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/organizationgroups/{ogid}/certificateauthorities/{certificateAuthorityId}/certificatetemplates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_credential_certificate_store_for_windows_pc(self, **kwargs):  # noqa: E501
        """Returns Crdential Certificate Store for Windows PC platform.  # noqa: E501

        Gets a list of supported credential certificate store for credentials profile.  Example : Personal, Trusted Root certificate authorities, Trusted publishers, untrusted publishers, Trusted people, Intermediate.  default is Personal.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_certificate_store_for_windows_pc(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_credential_certificate_store_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_credential_certificate_store_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_credential_certificate_store_for_windows_pc_with_http_info(self, **kwargs):  # noqa: E501
        """Returns Crdential Certificate Store for Windows PC platform.  # noqa: E501

        Gets a list of supported credential certificate store for credentials profile.  Example : Personal, Trusted Root certificate authorities, Trusted publishers, untrusted publishers, Trusted people, Intermediate.  default is Personal.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_certificate_store_for_windows_pc_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_credential_certificate_store_for_windows_pc" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowspccredentialcertificatestore', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_credential_smime_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for the Credential Smime(Smime) for Apple Credentials profile.  # noqa: E501

        Smime detetrmines the encryption and signing requirements for email.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_smime_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_credential_smime_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_credential_smime_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_credential_smime_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for the Credential Smime(Smime) for Apple Credentials profile.  # noqa: E501

        Smime detetrmines the encryption and signing requirements for email.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_smime_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_credential_smime_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/applecredentialsmime', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_credential_source_for_android(self, **kwargs):  # noqa: E501
        """Gets Credential Source for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_source_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_credential_source_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_credential_source_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_credential_source_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Credential Source for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_source_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_credential_source_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidcredentialsource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_credential_source_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Credential Source(CertificateSource) for Apple Credentials profile.  # noqa: E501

        CertificateSource determines the source of the certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_source_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_credential_source_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_credential_source_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_credential_source_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Credential Source(CertificateSource) for Apple Credentials profile.  # noqa: E501

        CertificateSource determines the source of the certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_source_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_credential_source_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/applecredentialsource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_credential_source_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets valid CredentialSources(CertificateSource) for Apple macOS platform.  # noqa: E501

        CertificateSource determines the source of the certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_source_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_credential_source_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_credential_source_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_credential_source_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets valid CredentialSources(CertificateSource) for Apple macOS platform.  # noqa: E501

        CertificateSource determines the source of the certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_source_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_credential_source_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxcredentialsource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_credential_source_for_windows_mobile(self, **kwargs):  # noqa: E501
        """Gets Credential Source for WindowsMobile.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_source_for_windows_mobile(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_credential_source_for_windows_mobile_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_credential_source_for_windows_mobile_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_credential_source_for_windows_mobile_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Credential Source for WindowsMobile.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_source_for_windows_mobile_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_credential_source_for_windows_mobile" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowsmobilecredentialsource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_credential_source_for_windows_pc(self, **kwargs):  # noqa: E501
        """Returns Crdential Source for Windows PC platform.  # noqa: E501

        Gets a list of supported credential source for credentials profile.  Example : DefinedCertificateAuthority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_source_for_windows_pc(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_credential_source_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_credential_source_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_credential_source_for_windows_pc_with_http_info(self, **kwargs):  # noqa: E501
        """Returns Crdential Source for Windows PC platform.  # noqa: E501

        Gets a list of supported credential source for credentials profile.  Example : DefinedCertificateAuthority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_source_for_windows_pc_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_credential_source_for_windows_pc" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowspccredentialsource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_credential_store_location_for_windows_pc(self, **kwargs):  # noqa: E501
        """Returns Crdential Store Location for Windows PC platform.  # noqa: E501

        Gets a list of supported credential store locations for credentials profile.  Example : User Account, System Account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_store_location_for_windows_pc(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_credential_store_location_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_credential_store_location_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_credential_store_location_for_windows_pc_with_http_info(self, **kwargs):  # noqa: E501
        """Returns Crdential Store Location for Windows PC platform.  # noqa: E501

        Gets a list of supported credential store locations for credentials profile.  Example : User Account, System Account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_credential_store_location_for_windows_pc_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_credential_store_location_for_windows_pc" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowspccredentialstorelocation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_device_category_list(self, **kwargs):  # noqa: E501
        """Gets device category list.  # noqa: E501

        Gets the list of all the available device categories from the picklist Eg.Apple.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_device_category_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_device_category_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_device_category_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_device_category_list_with_http_info(self, **kwargs):  # noqa: E501
        """Gets device category list.  # noqa: E501

        Gets the list of all the available device categories from the picklist Eg.Apple.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_device_category_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_device_category_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/devicecategories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_device_model_list(self, platform, **kwargs):  # noqa: E501
        """Gets device model list.  # noqa: E501

        Gets the list of all the available device models loaded from the picklist for the specified platform.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_device_model_list(platform, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str platform: device platform name Eg:APPLE (Required). (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_device_model_list_with_http_info(platform, **kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_device_model_list_with_http_info(platform, **kwargs)  # noqa: E501
            return data

    def pick_lists_get_device_model_list_with_http_info(self, platform, **kwargs):  # noqa: E501
        """Gets device model list.  # noqa: E501

        Gets the list of all the available device models loaded from the picklist for the specified platform.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_device_model_list_with_http_info(platform, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str platform: device platform name Eg:APPLE (Required). (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['platform']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_device_model_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'platform' is set
        if self.api_client.client_side_validation and ('platform' not in params or
                                                       params['platform'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `platform` when calling `pick_lists_get_device_model_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'platform' in params:
            path_params['platform'] = params['platform']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/platforms/{platform}/devicemodels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_device_type_list(self, **kwargs):  # noqa: E501
        """Gets device type list.  # noqa: E501

        Gets the list of all the available device types from the picklist Eg.Apple, Android.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_device_type_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_device_type_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_device_type_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_device_type_list_with_http_info(self, **kwargs):  # noqa: E501
        """Gets device type list.  # noqa: E501

        Gets the list of all the available device types from the picklist Eg.Apple, Android.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_device_type_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_device_type_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/devicetypes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_authentication_type_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas Authentication Type for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_authentication_type_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_authentication_type_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_authentication_type_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_authentication_type_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas Authentication Type for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_authentication_type_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_authentication_type_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideasauthenticationtype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_auto_lock_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas Auto Lock for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_auto_lock_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_auto_lock_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_auto_lock_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_auto_lock_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas Auto Lock for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_auto_lock_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_auto_lock_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideasautolock', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_aw_email_client_complexity_for_apple(self, **kwargs):  # noqa: E501
        """Gets EAS AW Email Client Passcode Complexity for Apple.  # noqa: E501

        Returns the expected passcode complexity for Email account of EAS profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_complexity_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_aw_email_client_complexity_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_aw_email_client_complexity_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_aw_email_client_complexity_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets EAS AW Email Client Passcode Complexity for Apple.  # noqa: E501

        Returns the expected passcode complexity for Email account of EAS profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_complexity_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_aw_email_client_complexity_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleeasawemailclientcomplexity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_aw_email_client_email_notifications_for_apple(self, **kwargs):  # noqa: E501
        """Gets EAS AW Email Client Email Notifications(Notifications) for Apple AirWatch EAS profile.  # noqa: E501

        Notifications determines the emaiil client notifications for the email.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_email_notifications_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_aw_email_client_email_notifications_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_aw_email_client_email_notifications_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_aw_email_client_email_notifications_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets EAS AW Email Client Email Notifications(Notifications) for Apple AirWatch EAS profile.  # noqa: E501

        Notifications determines the emaiil client notifications for the email.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_email_notifications_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_aw_email_client_email_notifications_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleeasawemailclientemailnotifications', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_aw_email_client_history_for_apple(self, **kwargs):  # noqa: E501
        """Gets EAS AW Email Client Passcode History for Apple.  # noqa: E501

        Returns passcode history for email account of EAS profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_history_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_aw_email_client_history_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_aw_email_client_history_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_aw_email_client_history_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets EAS AW Email Client Passcode History for Apple.  # noqa: E501

        Returns passcode history for email account of EAS profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_history_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_aw_email_client_history_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleeasawemailclienthistory', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_aw_email_client_max_number_of_failed_attempts_for_apple(self, **kwargs):  # noqa: E501
        """Gets EAS AW Email Client Maximum Failed Attempts for Apple.  # noqa: E501

        Returns valid value for max failed attempts for email account of EAS profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_max_number_of_failed_attempts_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_aw_email_client_max_number_of_failed_attempts_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_aw_email_client_max_number_of_failed_attempts_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_aw_email_client_max_number_of_failed_attempts_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets EAS AW Email Client Maximum Failed Attempts for Apple.  # noqa: E501

        Returns valid value for max failed attempts for email account of EAS profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_max_number_of_failed_attempts_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_aw_email_client_max_number_of_failed_attempts_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleeasawemailclientmaximumfailedattempts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_aw_email_client_passcode_type_for_apple(self, **kwargs):  # noqa: E501
        """Gets EAS AW Email Client Passcode Type for Apple.  # noqa: E501

        Returns valid values for the Authentication type which can be used for EAS AW Email Client.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_passcode_type_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_aw_email_client_passcode_type_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_aw_email_client_passcode_type_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_aw_email_client_passcode_type_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets EAS AW Email Client Passcode Type for Apple.  # noqa: E501

        Returns valid values for the Authentication type which can be used for EAS AW Email Client.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_passcode_type_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_aw_email_client_passcode_type_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleeasawemailclientpasscodetype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_aw_email_client_past_days_of_calendar_to_sync_for_apple(self, **kwargs):  # noqa: E501
        """Gets the number of days' calendar to sync.  # noqa: E501

        returns values that can be configured for EAS AW Email Client Past Days of Calendar to Sync for Apple.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_past_days_of_calendar_to_sync_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_aw_email_client_past_days_of_calendar_to_sync_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_aw_email_client_past_days_of_calendar_to_sync_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_aw_email_client_past_days_of_calendar_to_sync_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the number of days' calendar to sync.  # noqa: E501

        returns values that can be configured for EAS AW Email Client Past Days of Calendar to Sync for Apple.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_past_days_of_calendar_to_sync_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_aw_email_client_past_days_of_calendar_to_sync_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleeasawemailclientpastdaysofcalendartosync', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_aw_email_client_past_days_of_mail_to_sync_for_apple(self, **kwargs):  # noqa: E501
        """Gets the number of days' mail to sync.  # noqa: E501

        Values that can be configured for the EAS AW Email Client Past Days of Mail to Sync(MaxEmailAge) for Apple.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_past_days_of_mail_to_sync_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_aw_email_client_past_days_of_mail_to_sync_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_aw_email_client_past_days_of_mail_to_sync_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_aw_email_client_past_days_of_mail_to_sync_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the number of days' mail to sync.  # noqa: E501

        Values that can be configured for the EAS AW Email Client Past Days of Mail to Sync(MaxEmailAge) for Apple.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_past_days_of_mail_to_sync_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_aw_email_client_past_days_of_mail_to_sync_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleeasawemailclientpastdaysofmailtosync', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_aw_email_client_sync_interval_for_apple(self, **kwargs):  # noqa: E501
        """SyncInterval determines the sync interval for the email.  # noqa: E501

        Gets the values that can be configured for EAS AW Email Client Sync Interval(SyncInterval) for Apple AirWatch EAS profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_sync_interval_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_aw_email_client_sync_interval_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_aw_email_client_sync_interval_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_aw_email_client_sync_interval_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """SyncInterval determines the sync interval for the email.  # noqa: E501

        Gets the values that can be configured for EAS AW Email Client Sync Interval(SyncInterval) for Apple AirWatch EAS profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_aw_email_client_sync_interval_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_aw_email_client_sync_interval_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleeasawemailclientsyncinterval', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_calendar_application_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas Calendar Application for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_calendar_application_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_calendar_application_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_calendar_application_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_calendar_application_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas Calendar Application for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_calendar_application_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_calendar_application_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideascalendarapplication', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_contacts_application_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas Contacts Application for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_contacts_application_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_contacts_application_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_contacts_application_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_contacts_application_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas Contacts Application for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_contacts_application_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_contacts_application_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideascontactsapplication', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_mail_client_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas Mail Client for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_mail_client_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_mail_client_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_mail_client_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_mail_client_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas Mail Client for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_mail_client_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_mail_client_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideasmailclient', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_maximum_passcode_age_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas Maximum Passcode Age for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_maximum_passcode_age_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_maximum_passcode_age_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_maximum_passcode_age_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_maximum_passcode_age_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas Maximum Passcode Age for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_maximum_passcode_age_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_maximum_passcode_age_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideasmaximumpasscodeage', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_minimum_passcode_length_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas Minimum Passcode length for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_minimum_passcode_length_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_minimum_passcode_length_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_minimum_passcode_length_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_minimum_passcode_length_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas Minimum Passcode length for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_minimum_passcode_length_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_minimum_passcode_length_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideasminimumpasscodelength', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_passcode_complexity_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas Passcode Complexity for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_passcode_complexity_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_passcode_complexity_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_passcode_complexity_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_passcode_complexity_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas Passcode Complexity for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_passcode_complexity_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_passcode_complexity_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideaspasscodecomplexity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_past_days_of_calendar_to_sync_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas past days of calendar to sync for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_past_days_of_calendar_to_sync_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_past_days_of_calendar_to_sync_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_past_days_of_calendar_to_sync_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_past_days_of_calendar_to_sync_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas past days of calendar to sync for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_past_days_of_calendar_to_sync_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_past_days_of_calendar_to_sync_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideaspastdaysofcalendartosync', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_past_days_of_mail_to_sync_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas past days of mail to sync for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_past_days_of_mail_to_sync_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_past_days_of_mail_to_sync_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_past_days_of_mail_to_sync_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_past_days_of_mail_to_sync_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas past days of mail to sync for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_past_days_of_mail_to_sync_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_past_days_of_mail_to_sync_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideaspastdaysofmailtosync', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_past_days_of_mail_to_sync_for_apple(self, **kwargs):  # noqa: E501
        """Gets the the number of days' mail to be synced.  # noqa: E501

        MailNumberOfPastDaysToSync specifies values that can be configured for Eas Past Days of Mail to Sync(MailNumberOfPastDaysToSync) for Apple EAS profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_past_days_of_mail_to_sync_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_past_days_of_mail_to_sync_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_past_days_of_mail_to_sync_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_past_days_of_mail_to_sync_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the the number of days' mail to be synced.  # noqa: E501

        MailNumberOfPastDaysToSync specifies values that can be configured for Eas Past Days of Mail to Sync(MailNumberOfPastDaysToSync) for Apple EAS profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_past_days_of_mail_to_sync_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_past_days_of_mail_to_sync_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleeaspastdaysofmailtosync', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_peak_time_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas Peak Time for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_peak_time_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_peak_time_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_peak_time_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_peak_time_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas Peak Time for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_peak_time_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_peak_time_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideaspeaktime', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_restriction_type_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas Restriction Type for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_restriction_type_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_restriction_type_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_restriction_type_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_restriction_type_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas Restriction Type for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_restriction_type_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_restriction_type_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideasrestrictiontype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_sync_interval_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas Sync Interval for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_sync_interval_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_sync_interval_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_sync_interval_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_sync_interval_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas Sync Interval for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_sync_interval_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_sync_interval_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideassyncinterval', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_eas_sync_schedule_for_android(self, **kwargs):  # noqa: E501
        """Gets Eas Sync Schedule for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_sync_schedule_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_eas_sync_schedule_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_eas_sync_schedule_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_eas_sync_schedule_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Eas Sync Schedule for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_eas_sync_schedule_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_eas_sync_schedule_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androideassyncschedule', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_email_account_type_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Email Account Type(EmailAccountType).  # noqa: E501

        EmailAccountType determines the type of email (POP, IMAP) in Apple Email profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_email_account_type_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_email_account_type_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_email_account_type_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_email_account_type_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Email Account Type(EmailAccountType).  # noqa: E501

        EmailAccountType determines the type of email (POP, IMAP) in Apple Email profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_email_account_type_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_email_account_type_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleemailaccounttype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_email_account_type_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets valid Email Account types for Apple macOS Platform.  # noqa: E501

        Supported Account types for Email Profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_email_account_type_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_email_account_type_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_email_account_type_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_email_account_type_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets valid Email Account types for Apple macOS Platform.  # noqa: E501

        Supported Account types for Email Profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_email_account_type_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_email_account_type_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxemailaccounttype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_email_authentication_type_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets valid Email Authentication Types for Apple macOS Platform.  # noqa: E501

        Server authentication types for Email Profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_email_authentication_type_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_email_authentication_type_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_email_authentication_type_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_email_authentication_type_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets valid Email Authentication Types for Apple macOS Platform.  # noqa: E501

        Server authentication types for Email Profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_email_authentication_type_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_email_authentication_type_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxemailauthenticationtype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_email_sync_interval_for_android(self, **kwargs):  # noqa: E501
        """Gets E-Mail Sync Intervals for android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_email_sync_interval_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_email_sync_interval_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_email_sync_interval_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_email_sync_interval_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets E-Mail Sync Intervals for android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_email_sync_interval_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_email_sync_interval_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidemailsyncintervals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_encrypted_volume_for_windows_pc(self, **kwargs):  # noqa: E501
        """Returns Encrypted volume for Windows PC platform.  # noqa: E501

        Gets a list of encrypted volumes for encryption profile.  Example : Complete Hard Disk, System Partition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_encrypted_volume_for_windows_pc(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_encrypted_volume_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_encrypted_volume_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_encrypted_volume_for_windows_pc_with_http_info(self, **kwargs):  # noqa: E501
        """Returns Encrypted volume for Windows PC platform.  # noqa: E501

        Gets a list of encrypted volumes for encryption profile.  Example : Complete Hard Disk, System Partition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_encrypted_volume_for_windows_pc_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_encrypted_volume_for_windows_pc" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowspcencryptedvolume', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_font_size_for_android(self, **kwargs):  # noqa: E501
        """Gets Font Size for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_font_size_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_font_size_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_font_size_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_font_size_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Font Size for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_font_size_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_font_size_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidfontsize', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_grace_period_for_passcode_change_for_android(self, **kwargs):  # noqa: E501
        """Gets Android Grace Period for Passcode change.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_grace_period_for_passcode_change_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_grace_period_for_passcode_change_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_grace_period_for_passcode_change_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_grace_period_for_passcode_change_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Android Grace Period for Passcode change.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_grace_period_for_passcode_change_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_grace_period_for_passcode_change_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidgraceperiodforpasscodechange', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_important_updates_for_windows_pc(self, **kwargs):  # noqa: E501
        """Returns Important Updates for Windows PC platform.  # noqa: E501

        Gets a list of supported actions for important updates  Example : Install Updates Automatically, Download updates but let the user decide when to install them.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_important_updates_for_windows_pc(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_important_updates_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_important_updates_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_important_updates_for_windows_pc_with_http_info(self, **kwargs):  # noqa: E501
        """Returns Important Updates for Windows PC platform.  # noqa: E501

        Gets a list of supported actions for important updates  Example : Install Updates Automatically, Download updates but let the user decide when to install them.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_important_updates_for_windows_pc_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_important_updates_for_windows_pc" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowspcimportantupdates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_incoming_mail_server_authentication_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Incoming mail server authentication(IncomingMailServerAuthentication).  # noqa: E501

        IncomingMailServerAuthentication determines the authentication scheme for incoming mail in Apple Email profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_incoming_mail_server_authentication_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_incoming_mail_server_authentication_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_incoming_mail_server_authentication_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_incoming_mail_server_authentication_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Incoming mail server authentication(IncomingMailServerAuthentication).  # noqa: E501

        IncomingMailServerAuthentication determines the authentication scheme for incoming mail in Apple Email profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_incoming_mail_server_authentication_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_incoming_mail_server_authentication_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleincomingmailserverauthentication', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_incoming_mail_server_protocol_for_android(self, **kwargs):  # noqa: E501
        """Gets Incomming Mail Server Protocol for android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_incoming_mail_server_protocol_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_incoming_mail_server_protocol_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_incoming_mail_server_protocol_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_incoming_mail_server_protocol_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Incomming Mail Server Protocol for android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_incoming_mail_server_protocol_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_incoming_mail_server_protocol_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidincomingmailserverprotocol', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_inner_identity_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for inner authentication(TTLSInnerAuthentication) in Apple WIFI profile.  # noqa: E501

        TTLSInnerAuthentication determines inner authentication used by the TTLS module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_inner_identity_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_inner_identity_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_inner_identity_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_inner_identity_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for inner authentication(TTLSInnerAuthentication) in Apple WIFI profile.  # noqa: E501

        TTLSInnerAuthentication determines inner authentication used by the TTLS module.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_inner_identity_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_inner_identity_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/applewifiinneridentity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_machine_authentication_for_apple(self, **kwargs):  # noqa: E501
        """Gets values that can be configured for Machine Authentication (IPSecAuthenticationMode) for Apple VPN profile.  # noqa: E501

        Machine Authentication methods available for VPN profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_machine_authentication_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_machine_authentication_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_machine_authentication_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_machine_authentication_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets values that can be configured for Machine Authentication (IPSecAuthenticationMode) for Apple VPN profile.  # noqa: E501

        Machine Authentication methods available for VPN profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_machine_authentication_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_machine_authentication_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/applemachineauthentication', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_max_mails_to_show_for_android(self, **kwargs):  # noqa: E501
        """Gets Maximum E-mails to show for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_max_mails_to_show_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_max_mails_to_show_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_max_mails_to_show_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_max_mails_to_show_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Maximum E-mails to show for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_max_mails_to_show_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_max_mails_to_show_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidmaxmailstoshow', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_min_wifi_security_for_android(self, **kwargs):  # noqa: E501
        """Gets Minimum Wifi Security for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_min_wifi_security_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_min_wifi_security_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_min_wifi_security_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_min_wifi_security_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Minimum Wifi Security for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_min_wifi_security_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_min_wifi_security_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidminwifisecurity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_network_inner_identity_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets Network Inner Identity of TTLS protocol in Apple macOS Wi-Fi payload.  # noqa: E501

        Inner Authentication required for TTLS protocol.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_network_inner_identity_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_network_inner_identity_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_network_inner_identity_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_network_inner_identity_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Network Inner Identity of TTLS protocol in Apple macOS Wi-Fi payload.  # noqa: E501

        Inner Authentication required for TTLS protocol.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_network_inner_identity_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_network_inner_identity_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxnetworkinneridentity', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_network_interface_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets Network Interfaces for Apple macOS Platform.  # noqa: E501

        Supported interfaces(Wi-Fi, Ethernet) for Network profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_network_interface_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_network_interface_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_network_interface_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_network_interface_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Network Interfaces for Apple macOS Platform.  # noqa: E501

        Supported interfaces(Wi-Fi, Ethernet) for Network profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_network_interface_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_network_interface_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxnetworkinterface', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_network_proxy_types_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets Valid ProxyTypes for Apple macOS Wi-Fi Payload.  # noqa: E501

        Proxy types supported for Network profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_network_proxy_types_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_network_proxy_types_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_network_proxy_types_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_network_proxy_types_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Valid ProxyTypes for Apple macOS Wi-Fi Payload.  # noqa: E501

        Proxy types supported for Network profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_network_proxy_types_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_network_proxy_types_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxnetworkproxytype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_network_security_type_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets Network Security Protocols for Apple macOS Wi-Fi payload.  # noqa: E501

        Supported Security protocols(WEP, WPA / WPA2) for Network profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_network_security_type_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_network_security_type_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_network_security_type_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_network_security_type_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Network Security Protocols for Apple macOS Wi-Fi payload.  # noqa: E501

        Supported Security protocols(WEP, WPA / WPA2) for Network profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_network_security_type_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_network_security_type_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxnetworksecuritytype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_operating_system_list(self, platform, **kwargs):  # noqa: E501
        """Gets operating systems list.  # noqa: E501

        Gets the list of all the available operating systems from the picklist for the specified platform Eg.iOS 4.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_operating_system_list(platform, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str platform: device platform name Eg:APPLE (Required). (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_operating_system_list_with_http_info(platform, **kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_operating_system_list_with_http_info(platform, **kwargs)  # noqa: E501
            return data

    def pick_lists_get_operating_system_list_with_http_info(self, platform, **kwargs):  # noqa: E501
        """Gets operating systems list.  # noqa: E501

        Gets the list of all the available operating systems from the picklist for the specified platform Eg.iOS 4.0.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_operating_system_list_with_http_info(platform, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str platform: device platform name Eg:APPLE (Required). (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['platform']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_operating_system_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'platform' is set
        if self.api_client.client_side_validation and ('platform' not in params or
                                                       params['platform'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `platform` when calling `pick_lists_get_operating_system_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'platform' in params:
            path_params['platform'] = params['platform']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/platforms/{platform}/operatingsystems', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_outgoing_mail_server_authentication_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Outgoing mail server authentication(IncomingMailServerAuthentication).  # noqa: E501

        IncomingMailServerAuthentication determines the authentication scheme for outgoing mail in Apple Email profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_outgoing_mail_server_authentication_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_outgoing_mail_server_authentication_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_outgoing_mail_server_authentication_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_outgoing_mail_server_authentication_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Outgoing mail server authentication(IncomingMailServerAuthentication).  # noqa: E501

        IncomingMailServerAuthentication determines the authentication scheme for outgoing mail in Apple Email profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_outgoing_mail_server_authentication_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_outgoing_mail_server_authentication_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleoutgoingmailserverauthentication', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_outgoing_mail_server_protocol_for_android(self, **kwargs):  # noqa: E501
        """Gets Outgoing Mail Server Protocol for android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_outgoing_mail_server_protocol_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_outgoing_mail_server_protocol_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_outgoing_mail_server_protocol_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_outgoing_mail_server_protocol_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Outgoing Mail Server Protocol for android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_outgoing_mail_server_protocol_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_outgoing_mail_server_protocol_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidoutgoingmailserverprotocol', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_ownership_type_list(self, **kwargs):  # noqa: E501
        """Gets ownership type list.  # noqa: E501

        Gets the list of all the available ownership types from the picklist Eg.EmployeeOwned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_ownership_type_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_ownership_type_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_ownership_type_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_ownership_type_list_with_http_info(self, **kwargs):  # noqa: E501
        """Gets ownership type list.  # noqa: E501

        Gets the list of all the available ownership types from the picklist Eg.EmployeeOwned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_ownership_type_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_ownership_type_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/ownershiptypes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_passcode_auto_lock_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for passcode autolock in minutes(maxInactivity) in Apple passcode profile.  # noqa: E501

        Device automatically locks when time period elapses.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_passcode_auto_lock_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_passcode_auto_lock_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_passcode_auto_lock_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_passcode_auto_lock_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for passcode autolock in minutes(maxInactivity) in Apple passcode profile.  # noqa: E501

        Device automatically locks when time period elapses.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_passcode_auto_lock_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_passcode_auto_lock_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/applepasscodeautolock', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_passcode_auto_lock_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for passcode autolock in minutes(maxInactivity) in Apple macOS passcode profile.  # noqa: E501

        Device automatically locks when time period elapses.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_passcode_auto_lock_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_passcode_auto_lock_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_passcode_auto_lock_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_passcode_auto_lock_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for passcode autolock in minutes(maxInactivity) in Apple macOS passcode profile.  # noqa: E501

        Device automatically locks when time period elapses.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_passcode_auto_lock_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_passcode_auto_lock_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxpasscodeautolock', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_passcode_content_for_android(self, **kwargs):  # noqa: E501
        """Gets Passcode Content for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_passcode_content_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_passcode_content_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_passcode_content_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_passcode_content_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Passcode Content for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_passcode_content_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_passcode_content_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidpasscodecontent', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_passcode_grace_period_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for maximum grace period(maxGracePeriod) in Apple passcode profile.  # noqa: E501

        Amount of time device can be locked without prompting for passcode on unlock.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_passcode_grace_period_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_passcode_grace_period_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_passcode_grace_period_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_passcode_grace_period_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for maximum grace period(maxGracePeriod) in Apple passcode profile.  # noqa: E501

        Amount of time device can be locked without prompting for passcode on unlock.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_passcode_grace_period_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_passcode_grace_period_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/applepasscodegraceperiod', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_proxy_type_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Vpn proxy type(HTTPProxyType) in Apple VPN profile.  # noqa: E501

        HTTPProxyType determines proxy is manual or automatic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_proxy_type_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_proxy_type_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_proxy_type_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_proxy_type_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Vpn proxy type(HTTPProxyType) in Apple VPN profile.  # noqa: E501

        HTTPProxyType determines proxy is manual or automatic.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_proxy_type_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_proxy_type_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleproxytype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_rating_apps_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for rating apps (ratingApps) in Apple Restrictions profile.  # noqa: E501

        RatingApps determines the ratings of the apps that are allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_rating_apps_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_rating_apps_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_rating_apps_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_rating_apps_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for rating apps (ratingApps) in Apple Restrictions profile.  # noqa: E501

        RatingApps determines the ratings of the apps that are allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_rating_apps_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_rating_apps_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleratingapps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_rating_movies_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for rating movies (ratingMovies) in Apple Restrictions profile.  # noqa: E501

        RatingMovies determines the ratings of movies that are allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_rating_movies_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter_key: The key for filter countries.
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_rating_movies_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_rating_movies_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_rating_movies_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for rating movies (ratingMovies) in Apple Restrictions profile.  # noqa: E501

        RatingMovies determines the ratings of movies that are allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_rating_movies_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter_key: The key for filter countries.
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_rating_movies_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_key' in params:
            query_params.append(('filterKey', params['filter_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleratingmovies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_rating_region_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for rating region (ratingRegion) in Apple Restrictions profile.  # noqa: E501

        RatingRegion determine the regions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_rating_region_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_rating_region_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_rating_region_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_rating_region_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for rating region (ratingRegion) in Apple Restrictions profile.  # noqa: E501

        RatingRegion determine the regions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_rating_region_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_rating_region_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleratingregion', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_rating_tv_shows_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for rating tv shows (ratingTVShows) in Apple Restrictions profile.  # noqa: E501

        RatingTVShows determines the ratings of tv shows that are allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_rating_tv_shows_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter_key: The key for filter countries.
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_rating_tv_shows_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_rating_tv_shows_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_rating_tv_shows_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for rating tv shows (ratingTVShows) in Apple Restrictions profile.  # noqa: E501

        RatingTVShows determines the ratings of tv shows that are allowed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_rating_tv_shows_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str filter_key: The key for filter countries.
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['filter_key']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_rating_tv_shows_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filter_key' in params:
            query_params.append(('filterKey', params['filter_key']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleratingtvshows', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_restriction_allowed_applications_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets eligible applications to apply restriction of Apple macOS platform.  # noqa: E501

        Applicationsn list which are allowed to apply restrictions on.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_restriction_allowed_applications_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_restriction_allowed_applications_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_restriction_allowed_applications_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_restriction_allowed_applications_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets eligible applications to apply restriction of Apple macOS platform.  # noqa: E501

        Applicationsn list which are allowed to apply restrictions on.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_restriction_allowed_applications_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_restriction_allowed_applications_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxrestrictionallowedapplications', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_restriction_allowed_widgets_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets eligible widgets to apply restriction of Apple macOS platform.  # noqa: E501

        Widgets list which are allowed to apply restrictions on.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_restriction_allowed_widgets_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_restriction_allowed_widgets_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_restriction_allowed_widgets_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_restriction_allowed_widgets_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets eligible widgets to apply restriction of Apple macOS platform.  # noqa: E501

        Widgets list which are allowed to apply restrictions on.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_restriction_allowed_widgets_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_restriction_allowed_widgets_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxrestrictionallowedwidgets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_restriction_dataconnection_for_android(self, **kwargs):  # noqa: E501
        """Gets Restriction Data Connection for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_restriction_dataconnection_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_restriction_dataconnection_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_restriction_dataconnection_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_restriction_dataconnection_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Restriction Data Connection for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_restriction_dataconnection_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_restriction_dataconnection_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidrestrictiondataconnection', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_safari_accept_cookies_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for safari accept cookies(safariAcceptCookies) in Apple Restrictions profile.  # noqa: E501

        SafariAcceptCookies determines conditions under which the device will accept cookies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_safari_accept_cookies_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_safari_accept_cookies_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_safari_accept_cookies_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_safari_accept_cookies_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for safari accept cookies(safariAcceptCookies) in Apple Restrictions profile.  # noqa: E501

        SafariAcceptCookies determines conditions under which the device will accept cookies.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_safari_accept_cookies_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_safari_accept_cookies_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/applesafariacceptcookies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_scep_credential_source_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Credential Source(CertificateSource) for Apple SCEP profile.  # noqa: E501

        CertificateSource determines the source of the certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_scep_credential_source_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_scep_credential_source_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_scep_credential_source_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_scep_credential_source_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Credential Source(CertificateSource) for Apple SCEP profile.  # noqa: E501

        CertificateSource determines the source of the certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_scep_credential_source_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_scep_credential_source_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/applescepcredentialsource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_scep_credential_source_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets valid Scep CredentialSorces(CertificateSource) for Apple macOS platform.  # noqa: E501

        CertificateSource determines the source of the certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_scep_credential_source_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool include_supported_only: (Optional) Flag to indicate if only supported \"CredentialSource\" list is to be included or not.Default is False.
        :param bool include_airwatch_caif_enabled_in_og: (Optional) Flag to indicate to include Airwatch Certificate Authority only if its Enabled in the OG or not.Default is False.
        :param object organization_group_uuid: (Required if includeAirwatchCAIfEnabledInOg is true)OrganizationGroup's Uuid in which EnableAirwatchCA system code is to be checked for.
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_scep_credential_source_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_scep_credential_source_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_scep_credential_source_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets valid Scep CredentialSorces(CertificateSource) for Apple macOS platform.  # noqa: E501

        CertificateSource determines the source of the certificate.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_scep_credential_source_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool include_supported_only: (Optional) Flag to indicate if only supported \"CredentialSource\" list is to be included or not.Default is False.
        :param bool include_airwatch_caif_enabled_in_og: (Optional) Flag to indicate to include Airwatch Certificate Authority only if its Enabled in the OG or not.Default is False.
        :param object organization_group_uuid: (Required if includeAirwatchCAIfEnabledInOg is true)OrganizationGroup's Uuid in which EnableAirwatchCA system code is to be checked for.
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['include_supported_only', 'include_airwatch_caif_enabled_in_og', 'organization_group_uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_scep_credential_source_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include_supported_only' in params:
            query_params.append(('includeSupportedOnly', params['include_supported_only']))  # noqa: E501
        if 'include_airwatch_caif_enabled_in_og' in params:
            query_params.append(('includeAirwatchCAIfEnabledInOg', params['include_airwatch_caif_enabled_in_og']))  # noqa: E501
        if 'organization_group_uuid' in params:
            query_params.append(('organizationGroupUuid', params['organization_group_uuid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxscepcredentialsource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_security_type_for_android_wifi(self, **kwargs):  # noqa: E501
        """Gets Security Type for Android Wifi.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_security_type_for_android_wifi(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_security_type_for_android_wifi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_security_type_for_android_wifi_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_security_type_for_android_wifi_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Security Type for Android Wifi.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_security_type_for_android_wifi_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_security_type_for_android_wifi" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidwifisecuritytype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_security_type_for_windows_mobile_wifi(self, **kwargs):  # noqa: E501
        """Gets Security Type for Windows Mobile Wifi.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_security_type_for_windows_mobile_wifi(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_security_type_for_windows_mobile_wifi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_security_type_for_windows_mobile_wifi_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_security_type_for_windows_mobile_wifi_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Security Type for Windows Mobile Wifi.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_security_type_for_windows_mobile_wifi_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_security_type_for_windows_mobile_wifi" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowsmobilewifisecuritytype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_sfa_type_for_android_wifi(self, **kwargs):  # noqa: E501
        """Gets sfa Type for Androie Wifi.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_sfa_type_for_android_wifi(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_sfa_type_for_android_wifi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_sfa_type_for_android_wifi_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_sfa_type_for_android_wifi_with_http_info(self, **kwargs):  # noqa: E501
        """Gets sfa Type for Androie Wifi.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_sfa_type_for_android_wifi_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_sfa_type_for_android_wifi" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidwifisfatype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_smime_certificate_type_for_android(self, **kwargs):  # noqa: E501
        """Gets SMIME certificate type for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_smime_certificate_type_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_smime_certificate_type_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_smime_certificate_type_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_smime_certificate_type_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets SMIME certificate type for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_smime_certificate_type_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_smime_certificate_type_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidsmimecertificatetype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_tfa_type_for_android_wifi(self, **kwargs):  # noqa: E501
        """Gets Tfa Type for Android Wifi.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_tfa_type_for_android_wifi(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_tfa_type_for_android_wifi_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_tfa_type_for_android_wifi_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_tfa_type_for_android_wifi_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Tfa Type for Android Wifi.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_tfa_type_for_android_wifi_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_tfa_type_for_android_wifi" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidwifitfatype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_user_authentication_type_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for User Authentication Type for Apple VPN Profile.  # noqa: E501

        UserAuthenticationType determines the authentication type for the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_user_authentication_type_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_user_authentication_type_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_user_authentication_type_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_user_authentication_type_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for User Authentication Type for Apple VPN Profile.  # noqa: E501

        UserAuthenticationType determines the authentication type for the user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_user_authentication_type_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_user_authentication_type_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleuserauthenticationtype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_vpn_authentication_method_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Vpn authentication method(VpnAuthenticationMethod) in Apple VPN profile.  # noqa: E501

        VpnAuthenticationMethod determines the authentication method used for VPN.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_authentication_method_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_vpn_authentication_method_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_vpn_authentication_method_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_vpn_authentication_method_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for Vpn authentication method(VpnAuthenticationMethod) in Apple VPN profile.  # noqa: E501

        VpnAuthenticationMethod determines the authentication method used for VPN.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_authentication_method_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_vpn_authentication_method_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/applevpnauthenticationmethod', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_vpn_encryption_level_for_apple(self, **kwargs):  # noqa: E501
        """Gets values that can be configured for VPN encryption level(PP2PEncryptionLevel) for Apple VPN profile.  # noqa: E501

        PP2PEncryptionLevel determines the vpn encryption level.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_encryption_level_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_vpn_encryption_level_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_vpn_encryption_level_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_vpn_encryption_level_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets values that can be configured for VPN encryption level(PP2PEncryptionLevel) for Apple VPN profile.  # noqa: E501

        PP2PEncryptionLevel determines the vpn encryption level.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_encryption_level_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_vpn_encryption_level_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleencryptionlevel', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_vpn_encryption_level_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets values that can be configured for VPN encryption level(PP2PEncryptionLevel) for Apple macOS VPN profile.  # noqa: E501

        PP2PEncryptionLevel determines the vpn encryption level.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_encryption_level_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_vpn_encryption_level_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_vpn_encryption_level_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_vpn_encryption_level_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets values that can be configured for VPN encryption level(PP2PEncryptionLevel) for Apple macOS VPN profile.  # noqa: E501

        PP2PEncryptionLevel determines the vpn encryption level.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_encryption_level_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_vpn_encryption_level_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxvpnencryptionlevel', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_vpn_ike_id_type_for_android(self, **kwargs):  # noqa: E501
        """Gets Vpn IKE ID Type for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_ike_id_type_for_android(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_vpn_ike_id_type_for_android_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_vpn_ike_id_type_for_android_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_vpn_ike_id_type_for_android_with_http_info(self, **kwargs):  # noqa: E501
        """Gets Vpn IKE ID Type for Android.  # noqa: E501

        v1.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_ike_id_type_for_android_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_vpn_ike_id_type_for_android" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/androidvpnikeidtype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_vpn_machine_authentication_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets MachineAuthentication For Apple macOS VPN Profile.  # noqa: E501

        Authentication mode supported by VPN type for Machine Authentication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_machine_authentication_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_vpn_machine_authentication_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_vpn_machine_authentication_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_vpn_machine_authentication_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets MachineAuthentication For Apple macOS VPN Profile.  # noqa: E501

        Authentication mode supported by VPN type for Machine Authentication.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_machine_authentication_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_vpn_machine_authentication_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxvpnmachineauthentication', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_vpn_on_demand_type_for_apple_os_x(self, **kwargs):  # noqa: E501
        """Gets VPN OnDemandType values for Apple macOS platform.  # noqa: E501

        Supported for OnDemand Action values of VPN profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_on_demand_type_for_apple_os_x(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_vpn_on_demand_type_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_vpn_on_demand_type_for_apple_os_x_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_vpn_on_demand_type_for_apple_os_x_with_http_info(self, **kwargs):  # noqa: E501
        """Gets VPN OnDemandType values for Apple macOS platform.  # noqa: E501

        Supported for OnDemand Action values of VPN profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_on_demand_type_for_apple_os_x_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_vpn_on_demand_type_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxvpnondemandtypes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_vpn_proxy_for_apple_os_x_platform(self, **kwargs):  # noqa: E501
        """Gets VPN proxy types for Apple macOS platform.  # noqa: E501

        Proxy types valid for VPN profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_proxy_for_apple_os_x_platform(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_vpn_proxy_for_apple_os_x_platform_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_vpn_proxy_for_apple_os_x_platform_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_vpn_proxy_for_apple_os_x_platform_with_http_info(self, **kwargs):  # noqa: E501
        """Gets VPN proxy types for Apple macOS platform.  # noqa: E501

        Proxy types valid for VPN profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_proxy_for_apple_os_x_platform_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_vpn_proxy_for_apple_os_x_platform" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxvpnproxy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_vpn_type(self, platform, **kwargs):  # noqa: E501
        """Gets Vpn Types by Platform.  # noqa: E501

        Gets Vpn Payload picklist items for the specified platform(Ex. android, apple, appleosx, windowspc).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_type(platform, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str platform: Platform name (Required). (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_vpn_type_with_http_info(platform, **kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_vpn_type_with_http_info(platform, **kwargs)  # noqa: E501
            return data

    def pick_lists_get_vpn_type_with_http_info(self, platform, **kwargs):  # noqa: E501
        """Gets Vpn Types by Platform.  # noqa: E501

        Gets Vpn Payload picklist items for the specified platform(Ex. android, apple, appleosx, windowspc).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_type_with_http_info(platform, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str platform: Platform name (Required). (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['platform']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_vpn_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'platform' is set
        if self.api_client.client_side_validation and ('platform' not in params or
                                                       params['platform'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `platform` when calling `pick_lists_get_vpn_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'platform' in params:
            path_params['platform'] = params['platform']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/platforms/{platform}/vpntypes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_vpn_user_authentication_for_apple_os_x(self, vpn_type, **kwargs):  # noqa: E501
        """Gets Valid UserAuthentication for the specified VpnType.  # noqa: E501

        Authentication method supported by VpnType.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_user_authentication_for_apple_os_x(vpn_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str vpn_type: Vpn Type. (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_vpn_user_authentication_for_apple_os_x_with_http_info(vpn_type, **kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_vpn_user_authentication_for_apple_os_x_with_http_info(vpn_type, **kwargs)  # noqa: E501
            return data

    def pick_lists_get_vpn_user_authentication_for_apple_os_x_with_http_info(self, vpn_type, **kwargs):  # noqa: E501
        """Gets Valid UserAuthentication for the specified VpnType.  # noqa: E501

        Authentication method supported by VpnType.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_vpn_user_authentication_for_apple_os_x_with_http_info(vpn_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str vpn_type: Vpn Type. (required)
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['vpn_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_vpn_user_authentication_for_apple_os_x" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'vpn_type' is set
        if self.api_client.client_side_validation and ('vpn_type' not in params or
                                                       params['vpn_type'] is None):  # noqa: E501
            raise ValueError("Missing the required parameter `vpn_type` when calling `pick_lists_get_vpn_user_authentication_for_apple_os_x`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'vpn_type' in params:
            path_params['vpnType'] = params['vpn_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/appleosxvpnuserauthentication/{vpnType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_wifi_connection_mode_for_windows_pc(self, **kwargs):  # noqa: E501
        """Returns Valid Wifi Connection Modes for Windows PC platform.  # noqa: E501

        Gets a list of supported connection modes for wifi profile.  Example : Auto, Manual.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_wifi_connection_mode_for_windows_pc(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_wifi_connection_mode_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_wifi_connection_mode_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_wifi_connection_mode_for_windows_pc_with_http_info(self, **kwargs):  # noqa: E501
        """Returns Valid Wifi Connection Modes for Windows PC platform.  # noqa: E501

        Gets a list of supported connection modes for wifi profile.  Example : Auto, Manual.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_wifi_connection_mode_for_windows_pc_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_wifi_connection_mode_for_windows_pc" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowspcwificonnectionmode', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_wifi_connection_type_for_windows_pc(self, **kwargs):  # noqa: E501
        """Returns Valid Wifi Connection Types for Windows PC platform.  # noqa: E501

        Gets a list of supported connection types for wifi profile.  Example : Infrastructure, ad-hoc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_wifi_connection_type_for_windows_pc(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_wifi_connection_type_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_wifi_connection_type_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_wifi_connection_type_for_windows_pc_with_http_info(self, **kwargs):  # noqa: E501
        """Returns Valid Wifi Connection Types for Windows PC platform.  # noqa: E501

        Gets a list of supported connection types for wifi profile.  Example : Infrastructure, ad-hoc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_wifi_connection_type_for_windows_pc_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_wifi_connection_type_for_windows_pc" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowspcwificonnectiontype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_wifi_encryption_for_windows_pc(self, **kwargs):  # noqa: E501
        """Returns Valid Wifi Encryption Types for Windows PC platform.  # noqa: E501

        Gets a list of supported encryption algorithms Wifi profile.  Example : TKIP, AES.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_wifi_encryption_for_windows_pc(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_wifi_encryption_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_wifi_encryption_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_wifi_encryption_for_windows_pc_with_http_info(self, **kwargs):  # noqa: E501
        """Returns Valid Wifi Encryption Types for Windows PC platform.  # noqa: E501

        Gets a list of supported encryption algorithms Wifi profile.  Example : TKIP, AES.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_wifi_encryption_for_windows_pc_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_wifi_encryption_for_windows_pc" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowspcwifiencryptiontype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_wifi_proxy_type_for_apple(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for WIFI proxy type(ProxyType) in Apple WIFI profile.  # noqa: E501

        ProxyType determines if the proxy is automatic or manual.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_wifi_proxy_type_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_wifi_proxy_type_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_wifi_proxy_type_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_wifi_proxy_type_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets the values that can be configured for WIFI proxy type(ProxyType) in Apple WIFI profile.  # noqa: E501

        ProxyType determines if the proxy is automatic or manual.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_wifi_proxy_type_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_wifi_proxy_type_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/applewifiproxytype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_wifi_security_type_for_apple(self, **kwargs):  # noqa: E501
        """Gets values that can be configured for encryption type(EncryptionType) for Apple WIFI profile.  # noqa: E501

        EncryptionType determines the encryption type of the wifi configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_wifi_security_type_for_apple(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_wifi_security_type_for_apple_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_wifi_security_type_for_apple_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_wifi_security_type_for_apple_with_http_info(self, **kwargs):  # noqa: E501
        """Gets values that can be configured for encryption type(EncryptionType) for Apple WIFI profile.  # noqa: E501

        EncryptionType determines the encryption type of the wifi configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_wifi_security_type_for_apple_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_wifi_security_type_for_apple" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/applewifisecuritytype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_wifi_security_type_for_windows_pc(self, **kwargs):  # noqa: E501
        """Returns Valid Wifi Security Types for Windows PC platform.  # noqa: E501

        Gets a list of supported security types for wifi profile.  Example : WPA2 Personal, WPA Enterprise.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_wifi_security_type_for_windows_pc(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_wifi_security_type_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_wifi_security_type_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_wifi_security_type_for_windows_pc_with_http_info(self, **kwargs):  # noqa: E501
        """Returns Valid Wifi Security Types for Windows PC platform.  # noqa: E501

        Gets a list of supported security types for wifi profile.  Example : WPA2 Personal, WPA Enterprise.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_wifi_security_type_for_windows_pc_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_wifi_security_type_for_windows_pc" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowspcwifisecuritytype', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pick_lists_get_windows_update_source_for_windows_pc(self, **kwargs):  # noqa: E501
        """Returns Windows Update Source for Windows PC platform.  # noqa: E501

        Gets a list of supported update sources for windows update  Example : Microsoft, Corporate Wsus  Microsoft is default.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_windows_update_source_for_windows_pc(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pick_lists_get_windows_update_source_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.pick_lists_get_windows_update_source_for_windows_pc_with_http_info(**kwargs)  # noqa: E501
            return data

    def pick_lists_get_windows_update_source_for_windows_pc_with_http_info(self, **kwargs):  # noqa: E501
        """Returns Windows Update Source for Windows PC platform.  # noqa: E501

        Gets a list of supported update sources for windows update  Example : Microsoft, Corporate Wsus  Microsoft is default.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pick_lists_get_windows_update_source_for_windows_pc_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[PickListItem]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pick_lists_get_windows_update_source_for_windows_pc" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json;version=1', 'application/xml;version=1'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/xml'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'BasicAuth', 'CmsAuth']  # noqa: E501

        return self.api_client.call_api(
            '/picklists/windowspcupdatesource', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PickListItem]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
